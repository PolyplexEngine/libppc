/**
Copyright (c) 2018 Clipsey (clipseypone@gmail.com)

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module ppc.types.audio;
import ppc.backend.loaders.audio.ogg;
import ppc.backend.loaders.audio.wav;
import ppc.backend.loaders.audio.pcm;
import ppc.backend.loaders.audio;
import ppc.backend;
import ppc.backend.signatures;
import ppc.backend.cfile;

public {

    /// The type of audio
    enum AudioType : ubyte {
        OGG,
        WAV,
        PCM
    }

    /// Information about the audio
    /// this struct is tightly packed (no padding)
    struct AudioInfo {
    align(1):
        /// The type of audio format used.
        AudioType type;

        /// Version of audio format
        ubyte version_;

        /// The amount of channels
        ubyte channels;

        /// Bitrate of the audio stream
        size_t bitrate;

        /// Length of stream in samples
        size_t pcmLength;

        /// Length of stream in bytes
        size_t rawLength;
    }

    /// returns true if the type is a valid audio type.
    enum IsValidAudio(T) = (is(T : Ogg));

    /// A generic audio stream that can be read by OpenAL
    struct Audio {
    public:
        /// Information about the audio file
        AudioInfo info;

    private:
        AudioStream audioFile;
        MemFile* mref;

    public:
        /// Creates Audio from memory
        this(MemFile file) {
            // Detect the right file format to use.
            if (file.hasSignature(FileSignature.AudioOGG)) {
                audioFile = new Ogg(file);
                info = audioFile.genericInfo;
            }

            // Keep a reference to the file in memory so that the GC doesn't collect it by accident.
            this.mref = &file;
        }

        /// Creates audio from file
        this(string file) {
            MemFile f = loadFile(file);
            this(f);
        }

        /**
            Read [bufferLength] bytes from stream to [ptr] 
        */
        ulong read(byte* ptr, size_t bufferLength = 4096) {
            if (audioFile is null) return 0;
            return audioFile.read(ptr, cast(uint)bufferLength);
        }

        byte[] readAll(uint bitdepth = SAMPLE_DEPTH_16BIT, bool signed = SAMPLE_SIGNED) {
            import std.stdio;
            byte[] buff = new byte[4096];
            byte[] bytes;
            size_t bread = cast(size_t)this.read(buff.ptr);
            while (bread != 0) {
                bread = cast(size_t)this.read(buff.ptr);
                bytes ~= buff[0..bread];
            }
            return bytes;
        }

        /**
            Seek to a byte in the stream
        */
        void seek(long position = 0) {
            audioFile.seekRaw(position);
        }

        /**
            Seek to a sample in the stream
        */
        void seekSample(long position = 0) {
            audioFile.seek(position);
        }

        /// Returns the position in the stream
        size_t tell() {
            return audioFile.tell();
        }
    }
}