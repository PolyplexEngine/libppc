/**
Copyright (c) 2018 Clipsey (clipseypone@gmail.com)

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module ppc.types.font;
import ppc.backend;
import ppc.backend.cfile;
import ppc.backend.loaders.font;

public:

/++
    Flags describing the current font/glyph's properties
+/
// enum FontFlags : ubyte {
//     /// Font is a bitmap
//     FBITMAP  = 0b0000_0001,

//     /// Font file is bundled with the description
//     FBUNDLED = 0b0000_0010,

//     /// Font is external and the description refers to the font installed
//     FEXTERN  = 0b0000_0100,

//     FDYNAMIC = FBUNDLED | FEXTERN,

//     /// The glyph is dynamic (automatically generated on query)
//     GDYNAMIC = 0b0100_0000,

//     /// The glyph is unknown
//     GUNKNOWN = 0b1000_0000
// }

// /// Font is a bitmap
// enum FONT_FBITMAP   = FontFlags.FBITMAP;

// /// Font file is bundled with the description
// enum FONT_FBUNDLED  = FontFlags.FBUNDLED;

// /// Font is external and the description refers to the font installed
// enum FONT_FEXTERN   = FontFlags.FEXTERN;

// /// Font is either FBUNDLED or FEXTERN
// enum FONT_FDYNAMIC  = FontFlags.FDYNAMIC;

// /// The glyph is dynamic (automatically generated on query)
// enum GLYPH_GDYNAMIC = FontFlags.GDYNAMIC;

// /// The glyph is unknown
// enum GLYPH_GUNKNOWN = FontFlags.GUNKNOWN;


// /++
//     A glyph contains the relevant information needed to render a glyph from its parent font output bitmap.
//     This info is only relevant for graphics language rendering (Vulkan & OpenGL)

//     In some instances, a glyph can be automatically generated by the font backend (for example, freetype)
//     Other backends will return an Unknown glyph (defined via the UNKNOWN flag)
// +/
// struct Glyph {
//     GlyphCanvas* canvas;

//     /// Flags with info about the glyph
//     FontFlags flags;

//     /// The coordinates in the texture for the glyph
//     float[4] coords;

//     /// The bearing
//     float[2] bearing;

//     /// How many pixels to advance
//     size_t advance;
// }

// Glyph fromRawGlyph(GlyphInfo glyph, FontFlags flags) {
//     Glyph output;
//     output.flags = flags;
//     float gx = cast(float)glyph.x/cast(float)glyph.canvas.width;
//     float gy = cast(float)glyph.y/cast(float)glyph.canvas.height;
//     float gx2 = cast(float)(glyph.x+glyph.width)/cast(float)glyph.canvas.width;
//     float gy2 = cast(float)(glyph.y+glyph.height)/cast(float)glyph.canvas.height;
//     output.coords = [gx, gy, gx2, gy2];
//     output.bearing = [glyph.bearingX, glyph.bearingY];
//     output.advance = glyph.advance;
//     output.canvas = glyph.canvas;
//     return output;
// }

// /++
//     A glyph range contains info about the range of the font.

//     the `from` and `to` fields should only be modified when the font is being created and packaged (via ppcc)
//     Modifying them after will cause undefined behaviour.
// +/
// struct GlyphRange {
// private:
//     Font* parent;

// public:
//     /++
//         The character that the font range starts from

//         the `from` and `to` fields should only be modified when the font is being created and packaged (via ppcc)
//         Modifying them after will cause undefined behaviour.
//     +/
//     size_t from;

//     /++
//         The character that the font range starts ends at
        
//         the `from` and `to` fields should only be modified when the font is being created and packaged (via ppcc)
//         Modifying them after will cause undefined behaviour.
//     +/
//     size_t to;

//     /// returns true if the character is in range
//     bool charInRange(char c) {
//         return ((parent.flags & FONT_FDYNAMIC) > 0) || (cast(int)c >= from && cast(int)c <= to);
//     }

//     /// Returns true if the supplied string contains any characters that cannot be rendered by this glyph range.
//     bool hasInvalidChar(string text) {
//         if ((parent.flags & FONT_FDYNAMIC) > 0) return false;
//         foreach(c; text) {
//             if (!charInRange(c)) return true;
//         }
//         return false;
//     }
// }

// /++
//     A font is a collection of glyphs that can be rendered.
// +/
// struct Font {
// private:
//     FontSystem fsys;
//     Glyph[char] hlGlyphs;

// public:
//     /// Flags with info about the font
//     FontFlags flags;

//     /// Range of glyphs
//     GlyphRange range;

//     Glyph getGlyph(char c) {
//         if (c !in hlGlyphs) {
//             hlGlyphs[c] = fromRawGlyph(getRawGlyph(c), flags);
//         }
//         return hlGlyphs[c];
//     }

//     GlyphInfo getRawGlyph(char c) {
//         return fsys.getGlyph(c);
//     }
// }